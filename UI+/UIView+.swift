//
//  UIView+.swift
//  Elegant
//
//  Created by Steve on 2017/5/22.
//  Copyright © 2017年 KingCQ. All rights reserved.
//

import UIKit

public extension UIView {

    /// `self`'s all subviews include the subview's subviews.
    var flatSubviews: [UIView] {
        var views: [UIView] = []
        self.subviews.forEach { (sub) in
            views.append(sub)
            if !sub.subviews.isEmpty {
                views += sub.flatSubviews
            }
        }
        return views
    }
}

public extension UIView {

    ///  When positive, the background of the layer will be drawn with rounded corners. Also effects the mask generated by the`masksToBounds' property. Defaults to true. Animatable.
    func cornerRadius(_ radius: CGFloat) {
        layer.cornerRadius = radius
        layer.masksToBounds = true
    }

}

public extension UIView {

    /// Add tapGesture/action for particular event.
    ///
    /// - Parameters:
    ///   - tapNumber: Default is 1. The number of taps required to match
    ///   - target: `self`
    ///   - action: a `Selector`
    func addTapGesture(_ tapNumber: Int = 1, target: Any = self, action: Selector) {
        let tap = UITapGestureRecognizer(target: target, action: action)
        tap.numberOfTapsRequired = tapNumber
        isUserInteractionEnabled = true
        addGestureRecognizer(tap)
    }

    /// Returns an image of the current view
    ///
    /// - Parameter scale: scale
    /// - Returns: A new image
    func getSnapshot(scale: CGFloat = 0) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(bounds.size, false, scale)
        drawHierarchy(in: bounds, afterScreenUpdates: true)
        let image = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        return image
    }

    /// Remove all the subviews from `self`
    func removeSubviews() {
        subviews.forEach({ $0.removeFromSuperview() })
    }

    /// Remove all gesture recognizers from view.
    func removeGestureRecognizers() {
        gestureRecognizers?.forEach(removeGestureRecognizer)
    }

    /// resignFirstResponder from `self` or flatSubviews
    func removeFirstResponder() {
        if isFirstResponder {
            resignFirstResponder()
        }
        flatSubviews.forEach { (view) in
            if view.isFirstResponder {
                view.resignFirstResponder()
            }
        }
    }

}

// MARK: - Border
public extension UIView {

    /// To add the border for `self`
    /// - Parameters:
    ///   - width: The layer's borderWidth
    ///   - color: The layer's borderColor
    func addBorder(
        _ width: CGFloat,
        color: UIColor) {
        layer.borderWidth = width
        layer.borderColor = color.cgColor
        layer.masksToBounds = true
    }

    /// Add dashedBorder for `self`
    func addDashedBorder(
        _ strokeColor: UIColor = .red,
        fillColor: UIColor = .clear,
        width: CGFloat = 1,
        dashPattern: [NSNumber]? = [6, 3],
        cornerRadius: CGFloat = 5
    ) {
        let shapeLayer: CAShapeLayer = CAShapeLayer()
        shapeLayer.bounds = bounds
        shapeLayer.position = CGPoint(x: frame.size.width / 2, y: frame.size.height / 2)
        shapeLayer.fillColor = fillColor.cgColor
        shapeLayer.strokeColor = strokeColor.cgColor
        shapeLayer.lineWidth = width
        shapeLayer.lineJoin = kCALineJoinRound
        shapeLayer.lineDashPattern = dashPattern
        shapeLayer.path = UIBezierPath(roundedRect: bounds, cornerRadius: cornerRadius).cgPath
        layer.addSublayer(shapeLayer)
    }

    /// Add a line for `self`
    func addLine(
        _ color: UIColor = .red,
        width: CGFloat = 1,
        start: CGPoint,
        end: CGPoint
    ) {
        addDashLine(color,
                    width: width,
                    start: start,
                    end: end,
                    dashPattern: nil)
    }

    /// Add a dashLine for `self`
    func addDashLine(
        _ color: UIColor = .red,
        width: CGFloat = 1,
        start: CGPoint,
        end: CGPoint,
        dashPattern: [NSNumber]? = [6, 3]
    ) {
        let shapeLayer: CAShapeLayer = CAShapeLayer()
        shapeLayer.fillColor = UIColor.clear.cgColor
        shapeLayer.strokeColor = color.cgColor
        shapeLayer.lineWidth = width
        shapeLayer.lineJoin = kCALineJoinMiter
        shapeLayer.lineDashPattern = dashPattern
        let path = UIBezierPath()
        path.move(to: start)
        path.addLine(to: end)
        shapeLayer.path = path.cgPath
        layer.addSublayer(shapeLayer)
    }
}

// MARK: - Syntactic sugar for the frame
public extension UIView {

    var width: CGFloat {
        get { return frame.size.width }
        set {
            var frame = self.frame
            frame.size.width = newValue
            self.frame = frame
        }
    }

    var height: CGFloat {
        get { return frame.size.height }
        set {
            var frame = self.frame
            frame.size.height = newValue
            self.frame = frame
        }
    }

    var size: CGSize {
        get { return self.frame.size }
        set {
            var frame = self.frame
            frame.size = newValue
            self.frame = frame
        }
    }

    var origin: CGPoint {
        get { return self.frame.origin }
        set {
            var frame = self.frame
            frame.origin = newValue
            self.frame = frame
        }
    }

    var x: CGFloat {
        get { return self.frame.minX }
        set {
            var frame = self.frame
            frame.origin.x = newValue
            self.frame = frame
        }
    }

    var y: CGFloat {
        get { return self.frame.minY }
        set {
            var frame = self.frame
            frame.origin.y = newValue
            self.frame = frame
        }
    }

    var centerX: CGFloat {
        get { return self.center.x }
        set {
            self.center = CGPoint(x: newValue, y: self.center.y)
        }
    }

    var centerY: CGFloat {
        get { return self.center.y }
        set {
            self.center = CGPoint(x: self.center.x, y: newValue)
        }
    }

    var top: CGFloat {
        get { return self.y }
        set {
            var frame = self.frame
            frame.origin.y = newValue
            self.frame = frame
        }
    }

    var bottom: CGFloat {
        get { return self.frame.maxY }
        set {
            var frame = self.frame
            frame.origin.y = newValue - self.height
            self.frame = frame
        }
    }

    var right: CGFloat {
        get { return self.frame.maxX }
        set {
            var frame = self.frame
            frame.origin.x = newValue - self.frame.size.width
            self.frame = frame
        }
    }

    var left: CGFloat {
        get { return self.x }
        set {
            var frame = self.frame
            frame.origin.x = newValue
            self.frame = frame
        }
    }
}


// MARK: - add borders for `self`

public extension UIView {
    func addBorder(for edges: [UIRectEdge], width: CGFloat = 1, color: UIColor = .black, insets: UIEdgeInsets = UIEdgeInsets(all: 0)) {
        var edgesValues: [UIRectEdge] = edges
        if edges.contains(.all) {
            edgesValues = [.top, .bottom, .left, .right]
        }
        let allSpecificBorders:[UIRectEdge] = [.top, .bottom, .left, .right]
        for edge in allSpecificBorders {
            if let view = viewWithTag(Int(edge.rawValue)) {
                view.removeFromSuperview()
            }

            if edgesValues.contains(edge) {
                let view = UIView()
                view.tag = Int(edge.rawValue)
                view.backgroundColor = color
                view.translatesAutoresizingMaskIntoConstraints = false
                addSubview(view)
                var horizontalVisualFormat = "H:"
                var verticalVisualFormat = "V:"
                switch edge {
                case UIRectEdge.bottom:
                    horizontalVisualFormat += "|-(\(insets.left))-[v]-(\(insets.right))-|"
                    verticalVisualFormat += "[v(\(width))]-(\(insets.bottom))-|"
                case UIRectEdge.top:
                    horizontalVisualFormat += "|-(\(insets.left))-[v]-(\(insets.right))-|"
                    verticalVisualFormat += "|-(\(insets.top))-[v(\(width))]"
                case UIRectEdge.left:
                    horizontalVisualFormat += "|-(\(insets.left))-[v(\(width))]"
                    verticalVisualFormat += "|-(\(insets.top))-[v]-(\(insets.bottom))-|"
                case UIRectEdge.right:
                    horizontalVisualFormat += "[v(\(width))]-(\(insets.right))-|"
                    verticalVisualFormat += "|-(\(insets.left))-[v]-(\(insets.right))-|"
                default:
                    break
                }
                self.addConstraints(NSLayoutConstraint.constraints(withVisualFormat: horizontalVisualFormat, options: .directionLeadingToTrailing, metrics: nil, views: ["v": view]))
                self.addConstraints(NSLayoutConstraint.constraints(withVisualFormat: verticalVisualFormat, options: .directionLeadingToTrailing, metrics: nil, views: ["v": view]))
            }
        }
    }
}
